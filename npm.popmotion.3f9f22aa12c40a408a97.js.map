{"version":3,"file":"npm.popmotion.3f9f22aa12c40a408a97.js","mappings":"kLAGA,MAAMA,EAAU,KACVC,EAAc,IACdC,EAAc,GACdC,EAAa,IACbC,EAAa,EA2DnB,MAAMC,EAAiB,GAQvB,SAASC,EAAgBC,EAAcC,GACnC,OAAOD,EAAeE,KAAKC,KAAK,EAAIF,EAAeA,EACvD,CCzEA,MAAMG,EAAe,CAAC,WAAY,UAC5BC,EAAc,CAAC,YAAa,UAAW,QAC7C,SAASC,EAAaC,EAASC,GAC3B,OAAOA,EAAKC,MAAMC,QAAyBC,IAAjBJ,EAAQG,IACtC,CAWA,SAASE,EAAOC,GACZ,IAAI,KAAEC,EAAO,EAAG,GAAEC,EAAK,EAAG,UAAEC,EAAY,EAAC,UAAEC,GAAcJ,EAAIN,GAAU,QAAOM,EAAI,CAAC,OAAQ,KAAM,YAAa,cAC9G,MAAMK,EAAQ,CAAEC,MAAM,EAAOC,MAAON,GACpC,IAAI,UAAEO,EAAS,QAAEC,EAAO,KAAEC,EAAI,SAAEC,EAAQ,SAAEC,EAAQ,uBAAEC,GAbxD,SAA0BnB,GACtB,IAAIoB,EAAgBC,OAAOC,OAAO,CAAEL,SAAU,EAAKH,UAAW,IAAKC,QAAS,GAAIC,KAAM,EAAKG,wBAAwB,GAASnB,GAC5H,IAAKD,EAAaC,EAASF,IACvBC,EAAaC,EAASH,GAAe,CACrC,MAAM0B,EDJd,UAAoB,SAAEL,EAAW,IAAG,OAAEM,EAAS,IAAI,SAAEP,EAAW,EAAC,KAAED,EAAO,IACtE,IAAIS,EACAC,GACJ,OAAQR,GAA0B,IAAd9B,EAAoB,8CACxC,IAAIM,EAAe,EAAI8B,EACvB9B,GAAe,EAAAiC,EAAA,GAAMtC,EAAYC,EAAYI,GAC7CwB,GAAW,EAAAS,EAAA,GAAMxC,EAAaC,EAAa8B,EAAW,KAClDxB,EAAe,GACf+B,EAAYhC,IACR,MAAMmC,EAAmBnC,EAAeC,EAClCmC,EAAQD,EAAmBV,EAC3BY,EAAIF,EAAmBX,EACvBc,EAAIvC,EAAgBC,EAAcC,GAClCsC,EAAIrC,KAAKsC,KAAKJ,GACpB,OAAO3C,EAAW4C,EAAIC,EAAKC,CAAC,EAEhCN,EAAcjC,IACV,MACMoC,EADmBpC,EAAeC,EACPwB,EAC3BgB,EAAIL,EAAQZ,EAAWA,EACvBkB,EAAIxC,KAAKyC,IAAI1C,EAAc,GAAKC,KAAKyC,IAAI3C,EAAc,GAAKyB,EAC5DmB,EAAI1C,KAAKsC,KAAKJ,GACdS,EAAI9C,EAAgBG,KAAKyC,IAAI3C,EAAc,GAAIC,GAErD,QADgB+B,EAAShC,GAAgBP,EAAU,GAAK,EAAI,KACzCgD,EAAIC,GAAKE,GAAMC,CAAC,IAIvCb,EAAYhC,GACEE,KAAKsC,KAAKxC,EAAeyB,KACxBzB,EAAewB,GAAYC,EAAW,GACzChC,EAEZwC,EAAcjC,GACAE,KAAKsC,KAAKxC,EAAeyB,IACIA,EAAWA,GAAvCD,EAAWxB,KAI9B,MACMA,EAmBV,SAAyBgC,EAAUC,EAAYa,GAC3C,IAAIC,EAASD,EACb,IAAK,IAAIE,EAAI,EAAGA,EAAIlD,EAAgBkD,IAChCD,GAAkBf,EAASe,GAAUd,EAAWc,GAEpD,OAAOA,CACX,CAzByBE,CAAgBjB,EAAUC,EAD1B,EAAIR,GAGzB,GADAA,GAAsB,IAClByB,MAAMlD,GACN,MAAO,CACHqB,UAAW,IACXC,QAAS,GACTG,YAGH,CACD,MAAMJ,EAAYnB,KAAKyC,IAAI3C,EAAc,GAAKuB,EAC9C,MAAO,CACHF,YACAC,QAAwB,EAAfrB,EAAmBC,KAAKC,KAAKoB,EAAOF,GAC7CI,WAER,CACJ,CCrDwB0B,CAAW5C,GAC3BoB,EAAgBC,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAO,CAAC,EAAGF,GAAgBG,GAAU,CAAEN,SAAU,EAAKD,KAAM,IAC/GI,EAAcD,wBAAyB,CAC3C,CACA,OAAOC,CACX,CAIoFyB,CAAiB7C,GAC7F8C,EAAgBC,EAChBC,EAAkBD,EACtB,SAASE,IACL,MAAMC,EAAkBjC,GAAaA,EAAW,IAAQ,EAClDkC,EAAe3C,EAAKD,EACpBb,EAAeqB,GAAW,EAAIpB,KAAKC,KAAKkB,EAAYE,IACpDoC,EAAsBzD,KAAKC,KAAKkB,EAAYE,GAAQ,IAI1D,QAHkBZ,IAAdM,IACAA,EAAYf,KAAK0D,IAAI1D,KAAK2D,IAAI9C,EAAKD,GAAQ,IAAK,KAEhDb,EAAe,EAAG,CAClB,MAAM6D,EAAc/D,EAAgB4D,EAAqB1D,GACzDoD,EAAiBU,IACb,MAAM/B,EAAW9B,KAAKsC,KAAKvC,EAAe0D,EAAsBI,GAChE,OAAQhD,EACJiB,IACOyB,EACCxD,EAAe0D,EAAsBD,GACrCI,EACA5D,KAAK8D,IAAIF,EAAcC,GACvBL,EAAexD,KAAK+D,IAAIH,EAAcC,GAAI,EAE1DR,EAAmBQ,IACf,MAAM/B,EAAW9B,KAAKsC,KAAKvC,EAAe0D,EAAsBI,GAChE,OAAQ9D,EACJ0D,EACA3B,GACE9B,KAAK8D,IAAIF,EAAcC,IACpBN,EACGxD,EACI0D,EACAD,GACRI,EACAJ,EAAexD,KAAK+D,IAAIH,EAAcC,IAC1C/B,GACK9B,KAAK+D,IAAIH,EAAcC,IACnBN,EACGxD,EACI0D,EACAD,GACRI,EACIJ,EACAxD,KAAK8D,IAAIF,EAAcC,GAAI,CAEnD,MACK,GAAqB,IAAjB9D,EACLoD,EAAiBU,GAAMhD,EACnBb,KAAKsC,KAAKmB,EAAsBI,IAC3BL,GACID,EAAkBE,EAAsBD,GACrCK,OAEf,CACD,MAAMG,EAAoBP,EAAsBzD,KAAKC,KAAKF,EAAeA,EAAe,GACxFoD,EAAiBU,IACb,MAAM/B,EAAW9B,KAAKsC,KAAKvC,EAAe0D,EAAsBI,GAC1DI,EAAWjE,KAAK0D,IAAIM,EAAoBH,EAAG,KACjD,OAAQhD,EACHiB,IACKyB,EACExD,EAAe0D,EAAsBD,GACrCxD,KAAKkE,KAAKD,GACVD,EACIR,EACAxD,KAAKmE,KAAKF,IAClBD,CAAkB,CAElC,CACJ,CAEA,OADAV,IACO,CACHc,KAAOP,IACH,MAAMQ,EAAUlB,EAAcU,GAC9B,GAAKrC,EAQDR,EAAMC,KAAO4C,GAAKtC,MARO,CACzB,MAAM+C,EAAuC,IAArBjB,EAAgBQ,GAClCU,EAA2BvE,KAAK2D,IAAIW,IAAoBxD,EACxD0D,EAA+BxE,KAAK2D,IAAI9C,EAAKwD,IAAYtD,EAC/DC,EAAMC,KACFsD,GAA4BC,CACpC,CAKA,OADAxD,EAAME,MAAQF,EAAMC,KAAOJ,EAAKwD,EACzBrD,CAAK,EAEhByD,WAAY,KACRnD,GAAYA,GACXV,EAAMC,GAAM,CAACA,EAAID,GAClB0C,GAAc,EAG1B,CACA5C,EAAOgE,mBAAqB,CAACvC,EAAGC,IAAmB,iBAAND,GAA+B,iBAANC,EACtE,MAAMgB,EAAQuB,GAAO,E,gECpHrB,SAASC,EAASC,EAAGC,EAAGjB,GAKpB,OAJIA,EAAI,IACJA,GAAK,GACLA,EAAI,IACJA,GAAK,GACLA,EAAI,EAAI,EACDgB,EAAc,GAATC,EAAID,GAAShB,EACzBA,EAAI,GACGiB,EACPjB,EAAI,EAAI,EACDgB,GAAKC,EAAID,IAAM,EAAI,EAAIhB,GAAK,EAChCgB,CACX,CACA,SAASE,GAAW,IAAEC,EAAG,WAAEC,EAAU,UAAEC,EAAS,MAAEC,IAC9CH,GAAO,IAEPE,GAAa,IACb,IAAIE,EAAM,EACNC,EAAQ,EACRC,EAAO,EACX,GALAL,GAAc,IAQT,CACD,MAAMH,EAAII,EAAY,GAChBA,GAAa,EAAID,GACjBC,EAAYD,EAAaC,EAAYD,EACrCJ,EAAI,EAAIK,EAAYJ,EAC1BM,EAAMR,EAASC,EAAGC,EAAGE,EAAM,EAAI,GAC/BK,EAAQT,EAASC,EAAGC,EAAGE,GACvBM,EAAOV,EAASC,EAAGC,EAAGE,EAAM,EAAI,EACpC,MAVII,EAAMC,EAAQC,EAAOJ,EAWzB,MAAO,CACHE,IAAKpF,KAAKuF,MAAY,IAANH,GAChBC,MAAOrF,KAAKuF,MAAc,IAARF,GAClBC,KAAMtF,KAAKuF,MAAa,IAAPD,GACjBH,QAER,CCjCA,MAAMK,EAAiB,CAAC5E,EAAMC,EAAI4E,KAC9B,MAAMC,EAAW9E,EAAOA,EAClB+E,EAAS9E,EAAKA,EACpB,OAAOb,KAAKC,KAAKD,KAAK4F,IAAI,EAAGH,GAAKE,EAASD,GAAYA,GAAU,EAE/DG,EAAa,CAACC,EAAA,EAAKC,EAAA,EAAMC,EAAA,GACzBC,EAAgBR,GAAMI,EAAWK,MAAMC,GAASA,EAAKC,KAAKX,KAC1DY,EAAiBC,GAAU,IAAIA,wEAC/BC,EAAW,CAAC3F,EAAMC,KACpB,IAAI2F,EAAgBP,EAAarF,GAC7B6F,EAAcR,EAAapF,IAC/B,SAAY2F,EAAeH,EAAczF,KACzC,SAAY6F,EAAaJ,EAAcxF,IACvC,IAAI6F,EAAYF,EAAcG,MAAM/F,GAChCgG,EAAUH,EAAYE,MAAM9F,GAC5B2F,IAAkBR,EAAA,IAClBU,EAAY3B,EAAW2B,GACvBF,EAAgBT,EAAA,GAEhBU,IAAgBT,EAAA,IAChBY,EAAU7B,EAAW6B,GACrBH,EAAcV,EAAA,GAElB,MAAMc,EAAUnF,OAAOC,OAAO,CAAC,EAAG+E,GAClC,OAAQjB,IACJ,IAAK,MAAMjF,KAAOqG,EACF,UAARrG,IACAqG,EAAQrG,GAAOgF,EAAekB,EAAUlG,GAAMoG,EAAQpG,GAAMiF,IAIpE,OADAoB,EAAQ1B,OAAQ,EAAA2B,EAAA,GAAIJ,EAAUvB,MAAOyB,EAAQzB,MAAOM,GAC7Ce,EAAcO,UAAUF,EAAQ,CAC1C,E,oDC9BL,SAASG,EAASC,EAAQC,GACtB,OAAI,OAAMD,GACExB,IAAM,EAAAqB,EAAA,GAAIG,EAAQC,EAAQzB,GAE7Ba,EAAA,EAAMF,KAAKa,GACTV,EAASU,EAAQC,GAGjBC,EAAWF,EAAQC,EAElC,CACA,MAAME,EAAW,CAACxG,EAAMC,KACpB,MAAMwG,EAAS,IAAIzG,GACb0G,EAAYD,EAAOE,OACnBC,EAAa5G,EAAK6G,KAAI,CAACC,EAAU5E,IAAMkE,EAASU,EAAU7G,EAAGiC,MACnE,OAAQ2C,IACJ,IAAK,IAAI3C,EAAI,EAAGA,EAAIwE,EAAWxE,IAC3BuE,EAAOvE,GAAK0E,EAAW1E,GAAG2C,GAE9B,OAAO4B,CAAM,CAChB,EAECM,EAAY,CAACV,EAAQC,KACvB,MAAMG,EAAS3F,OAAOC,OAAOD,OAAOC,OAAO,CAAC,EAAGsF,GAASC,GAClDM,EAAa,CAAC,EACpB,IAAK,MAAMhH,KAAO6G,OACM5G,IAAhBwG,EAAOzG,SAAsCC,IAAhByG,EAAO1G,KACpCgH,EAAWhH,GAAOwG,EAASC,EAAOzG,GAAM0G,EAAO1G,KAGvD,OAAQiF,IACJ,IAAK,MAAMjF,KAAOgH,EACdH,EAAO7G,GAAOgH,EAAWhH,GAAKiF,GAElC,OAAO4B,CAAM,CAChB,EAEL,SAASO,EAAQ1G,GACb,MAAM2G,EAASC,EAAA,EAAQnB,MAAMzF,GACvBoG,EAAYO,EAAON,OACzB,IAAIQ,EAAa,EACbC,EAAS,EACTC,EAAS,EACb,IAAK,IAAInF,EAAI,EAAGA,EAAIwE,EAAWxE,IACvBiF,GAAmC,iBAAdF,EAAO/E,GAC5BiF,SAGsBtH,IAAlBoH,EAAO/E,GAAGkC,IACViD,IAGAD,IAIZ,MAAO,CAAEH,SAAQE,aAAYC,SAAQC,SACzC,CACA,MAAMd,EAAa,CAACF,EAAQC,KACxB,MAAMgB,EAAWJ,EAAA,EAAQK,kBAAkBjB,GACrCkB,EAAcR,EAAQX,GACtBoB,EAAcT,EAAQV,GAI5B,OAHuBkB,EAAYH,SAAWI,EAAYJ,QACtDG,EAAYJ,SAAWK,EAAYL,QACnCI,EAAYL,YAAcM,EAAYN,YAE/B,EAAAO,EAAA,GAAKlB,EAASgB,EAAYP,OAAQQ,EAAYR,QAASK,KAG9D,QAAQ,EAAM,mBAAmBjB,WAAgBC,6KACzCrC,GAAM,GAAGA,EAAI,EAAIqC,EAASD,IACtC,ECrEEsB,EAAY,CAAC3H,EAAMC,IAAQgE,IAAM,EAAAiC,EAAA,GAAIlG,EAAMC,EAAIgE,GA+DrD,SAAS2D,EAAYC,EAAOpB,GAAUrF,MAAO0G,GAAU,EAAI,KAAEC,EAAI,MAAEC,GAAU,CAAC,GAC1E,MAAMC,EAAcJ,EAAMlB,QAC1B,OAAUsB,IAAgBxB,EAAOE,OAAQ,yDACzC,QAAWoB,IAASG,MAAMC,QAAQJ,IAASA,EAAKpB,SAAWsB,EAAc,EAAG,oIACxEJ,EAAM,GAAKA,EAAMI,EAAc,KAC/BJ,EAAQ,GAAGO,OAAOP,GAClBpB,EAAS,GAAG2B,OAAO3B,GACnBoB,EAAMQ,UACN5B,EAAO4B,WAEX,MAAMC,EArDV,SAAsB7B,EAAQsB,EAAMQ,GAChC,MAAMD,EAAS,GACTE,EAAeD,IApBJ,iBADO1D,EAqB+B4B,EAAO,IAnBnDkB,EAEW,iBAAN9C,EACRa,EAAA,EAAMF,KAAKX,GACJc,EAGAY,EAGN2B,MAAMC,QAAQtD,GACZ2B,EAEW,iBAAN3B,EACLkC,OADN,GAfT,IAA4BlC,EAsBxB,MAAM4D,EAAYhC,EAAOE,OAAS,EAClC,IAAK,IAAIzE,EAAI,EAAGA,EAAIuG,EAAWvG,IAAK,CAChC,IAAI8F,EAAQQ,EAAa/B,EAAOvE,GAAIuE,EAAOvE,EAAI,IAC/C,GAAI6F,EAAM,CACN,MAAMW,EAAiBR,MAAMC,QAAQJ,GAAQA,EAAK7F,GAAK6F,EACvDC,GAAQ,EAAAN,EAAA,GAAKgB,EAAgBV,EACjC,CACAM,EAAOK,KAAKX,EAChB,CACA,OAAOM,CACX,CAwCmBM,CAAanC,EAAQsB,EAAMC,GACpCa,EAA+B,IAAhBZ,EAxCzB,UAA0BjI,EAAMC,IAAM+H,IAClC,OAAQnD,GAAMmD,GAAM,EAAAc,EAAA,GAAS9I,EAAMC,EAAI4E,GAC3C,CAuCUkE,CAAgBlB,EAAOS,GAtCjC,SAAyBT,EAAOS,GAC5B,MAAML,EAAcJ,EAAMlB,OACpBqC,EAAiBf,EAAc,EACrC,OAAQpD,IACJ,IAAIoE,EAAa,EACbC,GAAkB,EAQtB,GAPIrE,GAAKgD,EAAM,GACXqB,GAAkB,EAEbrE,GAAKgD,EAAMmB,KAChBC,EAAaD,EAAiB,EAC9BE,GAAkB,IAEjBA,EAAiB,CAClB,IAAIhH,EAAI,EACR,KAAOA,EAAI+F,KACHJ,EAAM3F,GAAK2C,GAAK3C,IAAM8G,GADN9G,KAKxB+G,EAAa/G,EAAI,CACrB,CACA,MAAMiH,GAAkB,EAAAL,EAAA,GAASjB,EAAMoB,GAAapB,EAAMoB,EAAa,GAAIpE,GAC3E,OAAOyD,EAAOW,GAAYE,EAAgB,CAElD,CAcUC,CAAgBvB,EAAOS,GAC7B,OAAOR,EACAjD,GAAMgE,GAAa,EAAAzH,EAAA,GAAMyG,EAAM,GAAIA,EAAMI,EAAc,GAAIpD,IAC5DgE,CACV,C,gBCtFA,SAASQ,EAAcC,EAAQC,GAC3B,OAAOD,EAAOzC,KAAI,IAAM0C,GAAU,OAAWC,OAAO,EAAGF,EAAO3C,OAAS,EAC3E,CAQA,SAAS8C,GAAU,KAAEzJ,EAAO,EAAC,GAAEC,EAAK,EAAC,KAAE8H,EAAI,OAAE2B,EAAM,SAAE/I,EAAW,MAC5D,MAAMP,EAAQ,CAAEC,MAAM,EAAOC,MAAON,GAC9BsJ,EAASpB,MAAMC,QAAQlI,GAAMA,EAAK,CAACD,EAAMC,GACzC0J,EANV,SAA8BD,EAAQ/I,GAClC,OAAO+I,EAAO7C,KAAK+C,GAAMA,EAAIjJ,GACjC,CAIkBkJ,CAAqBH,GAAUA,EAAO/C,SAAW2C,EAAO3C,OAChE+C,EAXV,SAAuBJ,GACnB,MAAM5C,EAAY4C,EAAO3C,OACzB,OAAO2C,EAAOzC,KAAI,CAACiD,EAAQ5H,IAAY,IAANA,EAAUA,GAAKwE,EAAY,GAAK,GACrE,CASUqD,CAAcT,GAAS3I,GAC7B,SAASqJ,IACL,OAAOpC,EAAY+B,EAAOL,EAAQ,CAC9BvB,KAAMG,MAAMC,QAAQJ,GAAQA,EAAOsB,EAAcC,EAAQvB,IAEjE,CACA,IAAIc,EAAemB,IACnB,MAAO,CACHxG,KAAOP,IACH7C,EAAME,MAAQuI,EAAa5F,GAC3B7C,EAAMC,KAAO4C,GAAKtC,EACXP,GAEXyD,WAAY,KACRyF,EAAOjB,UACPQ,EAAemB,GAAoB,EAG/C,CChCA,MAAMC,EAAQ,CAAER,UAAS,SAAQ,QCJjC,UAAe,SAAE/I,EAAW,EAAC,KAAEV,EAAO,EAAC,MAAEkK,EAAQ,GAAG,aAAEC,EAAe,IAAG,UAAEhK,EAAY,GAAG,aAAEiK,IACvF,MAAMhK,EAAQ,CAAEC,MAAM,EAAOC,MAAON,GACpC,IAAIqK,EAAYH,EAAQxJ,EACxB,MAAM4J,EAAQtK,EAAOqK,EACf/D,OAA0BzG,IAAjBuK,EAA6BE,EAAQF,EAAaE,GAGjE,OAFIhE,IAAWgE,IACXD,EAAY/D,EAAStG,GAClB,CACHwD,KAAOP,IACH,MAAM3B,GAAS+I,EAAYjL,KAAKsC,KAAKuB,EAAIkH,GAGzC,OAFA/J,EAAMC,OAASiB,EAAQnB,GAAamB,GAASnB,GAC7CC,EAAME,MAAQF,EAAMC,KAAOiG,EAASA,EAAShF,EACtClB,CAAK,EAEhByD,WAAY,OAEpB,G,gBChBA,SAAS0G,EAAYC,EAAS7J,EAAU8J,EAAQ,GAC5C,OAAOD,EAAU7J,EAAW8J,CAChC,CCIA,MAAMC,EAAaC,IACf,MAAMC,EAAgB,EAAGtJ,WAAYqJ,EAAOrJ,GAC5C,MAAO,CACHuJ,MAAO,IAAM,KAAKF,OAAOC,GAAe,GACxCE,KAAM,IAAM,KAAWH,OAAOC,GACjC,EAEL,SAASG,EAAQhL,GACb,IAAIiL,EAAIC,GACJ,KAAEjL,EAAI,SAAEkL,GAAW,EAAI,OAAEC,EAAST,EAAS,QAAEF,EAAU,EAAGY,OAAQC,EAAY,EAAC,WAAEC,EAAa,OAAM,YAAEC,EAAc,EAAC,OAAEC,EAAM,OAAEC,EAAM,WAAEC,EAAU,SAAEC,EAAQ,SAAEC,GAAa7L,EAAIN,GAAU,QAAOM,EAAI,CAAC,OAAQ,WAAY,SAAU,UAAW,SAAU,aAAc,cAAe,SAAU,SAAU,aAAc,WAAY,aACtU,IACI8L,EAGAC,EAGAC,GAPA,GAAE9L,GAAOR,EAETuM,EAAc,EACdC,EAAmBxM,EAAQkB,SAE3BuL,GAAa,EACbC,GAAoB,EAExB,MAAMC,EHnBV,SAAoCC,GAChC,GAAInE,MAAMC,QAAQkE,EAAOpM,IACrB,OAAOwJ,EAEN,GAAIQ,EAAMoC,EAAO9G,MAClB,OAAO0E,EAAMoC,EAAO9G,MAExB,MAAM7F,EAAO,IAAI4M,IAAIxL,OAAOpB,KAAK2M,IACjC,OAAI3M,EAAK6M,IAAI,SACR7M,EAAK6M,IAAI,cAAgB7M,EAAK6M,IAAI,gBAC5B9C,EAEF/J,EAAK6M,IAAI,iBACd7M,EAAK6M,IAAI,cACT7M,EAAK6M,IAAI,SACT7M,EAAK6M,IAAI,YACT7M,EAAK6M,IAAI,cACT7M,EAAK6M,IAAI,aACFzM,EAEJ2J,CACX,CGFqB+C,CAA2B/M,IACM,QAA7CwL,GAAMD,EAAKoB,GAAUtI,0BAAuC,IAAPmH,OAAgB,EAASA,EAAGwB,KAAKzB,EAAIhL,EAAMC,MACjG8L,EAAwBnE,EAAY,CAAC,EAAG,KAAM,CAAC5H,EAAMC,GAAK,CACtDmB,OAAO,IAEXpB,EAAO,EACPC,EAAK,KAET,MAAMyM,EAAYN,EAAStL,OAAOC,OAAOD,OAAOC,OAAO,CAAC,EAAGtB,GAAU,CAAEO,OAAMC,QAgD7E,OADAiL,IAJIM,SAAgDA,IAChDK,EAAiBV,GAzBrB,SAAgB7J,GAIZ,GAHK6K,IACD7K,GAASA,GACbkJ,GAAWlJ,GACN4K,EAAY,CACb,MAAM9L,EAAQsM,EAAUlJ,KAAKpE,KAAK4F,IAAI,EAAGwF,IACzCsB,EAAS1L,EAAME,MACXyL,IACAD,EAASC,EAAsBD,IACnCI,EAAaC,EAAoB/L,EAAMC,KAAOmK,GAAW,CAC7D,CACAoB,SAAoDA,EAASE,GACzDI,IACoB,IAAhBF,IACAC,UAA+EA,EAAmBzB,IAClGwB,EAAcX,ED1D9B,SAA+Bb,EAAS7J,EAAU8J,EAAO0B,GACrD,OAAOA,EAAoB3B,GAAW7J,EAAW8J,EAAQD,IAAYC,CACzE,CCyDgBkC,CAAsBnC,EAASyB,EAAkBV,EAAaY,KAjCtEH,IACmB,YAAfV,GACAa,EAAoBH,EAAc,GAAM,EACxCxB,EDlCZ,SAAwBA,EAAS7J,EAAU8J,EAAQ,EAAG0B,GAAoB,GACtE,OAAOA,EACD5B,EAAY5J,GAAY6J,EAAS7J,EAAU8J,GAC3C9J,GAAY6J,EAAU7J,GAAY8J,CAC5C,CC8BsBmC,CAAepC,EAASyB,EAAkBV,EAAaY,KAGjE3B,EAAUD,EAAYC,EAASyB,EAAkBV,GAC9B,WAAfD,GACAoB,EAAU7I,cAElBqI,GAAa,EACbP,GAAYA,MAGZE,EAAef,OACfY,GAAcA,KAwBlB,IAIIG,EAAehB,SAGZ,CACHC,KAAM,KACFW,SAAgDA,IAChDI,EAAef,MAAM,EAGjC,C,0EClFA,SAAS+B,GAAQ,KAAE7M,EAAO,EAAC,SAAEU,EAAW,EAAC,IAAEoC,EAAG,IAAEkC,EAAG,MAAEkF,EAAQ,GAAG,aAAEC,EAAe,IAAG,gBAAE2C,EAAkB,IAAG,cAAEC,EAAgB,GAAE,UAAE5M,EAAY,EAAC,aAAEiK,EAAY,OAAEe,EAAM,SAAES,EAAQ,WAAEF,EAAU,OAAED,IACxL,IAAIuB,EACJ,SAASC,EAAcpI,GACnB,YAAgBhF,IAARiD,GAAqB+B,EAAI/B,QAAiBjD,IAARmF,GAAqBH,EAAIG,CACvE,CACA,SAASkI,EAAgBrI,GACrB,YAAYhF,IAARiD,EACOkC,OACCnF,IAARmF,GAEG5F,KAAK2D,IAAID,EAAM+B,GAAKzF,KAAK2D,IAAIiC,EAAMH,GAD/B/B,EAC0CkC,CACzD,CACA,SAASmI,EAAe1N,GACpBuN,SAAoEA,EAAiBlC,OACrFkC,GAAmB,OAAQlM,OAAOC,OAAOD,OAAOC,OAAO,CAAC,EAAGtB,GAAU,CAAE0L,SAAQS,SAAW/G,IAClF,IAAI9E,EACJ6L,SAAoDA,EAAS/G,GACjC,QAA3B9E,EAAKN,EAAQmM,gBAA6B,IAAP7L,GAAyBA,EAAG0M,KAAKhN,EAASoF,EAAE,EACjF6G,aACHD,WACR,CACA,SAAS2B,EAAY3N,GACjB0N,EAAerM,OAAOC,OAAO,CAAEwE,KAAM,SAAUhF,UAAWuM,EAAiBtM,QAASuM,EAAe5M,aAAaV,GACpH,CACA,GAAIwN,EAAcjN,GACdoN,EAAY,CAAEpN,OAAMU,WAAUT,GAAIiN,EAAgBlN,SAEjD,CACD,IAAIsG,EAAS4D,EAAQxJ,EAAWV,OACJ,IAAjBoK,IACP9D,EAAS8D,EAAa9D,IAC1B,MAAM+G,EAAWH,EAAgB5G,GAC3BgH,EAAUD,IAAavK,GAAO,EAAI,EACxC,IAAIyK,EACA9J,EACJ,MAAM+J,EAAiB3I,IACnB0I,EAAO9J,EACPA,EAAUoB,EACVnE,GAAW,OAAkBmE,EAAI0I,GAAM,UAAejM,QACrC,IAAZgM,GAAiBzI,EAAIwI,IACR,IAAbC,GAAkBzI,EAAIwI,IACvBD,EAAY,CAAEpN,KAAM6E,EAAG5E,GAAIoN,EAAU3M,YACzC,EAEJyM,EAAe,CACX5H,KAAM,QACNvF,OACAU,WACAyJ,eACAD,QACA/J,YACAiK,eACAwB,SAAUqB,EAAc3G,GAAUkH,OAAgB3N,GAE1D,CACA,MAAO,CACHiL,KAAM,IAAMkC,aAA2D,EAASA,EAAiBlC,OAEzG,C,oDC5DA,MAAMvJ,EAAI,CAACkM,EAAIC,IAAO,EAAM,EAAMA,EAAK,EAAMD,EACvCjM,EAAI,CAACiM,EAAIC,IAAO,EAAMA,EAAK,EAAMD,EACjChM,EAAKgM,GAAO,EAAMA,EAClBE,EAAa,CAAC1K,EAAGwK,EAAIC,MAASnM,EAAEkM,EAAIC,GAAMzK,EAAIzB,EAAEiM,EAAIC,IAAOzK,EAAIxB,EAAEgM,IAAOxK,EACxE2K,EAAW,CAAC3K,EAAGwK,EAAIC,IAAO,EAAMnM,EAAEkM,EAAIC,GAAMzK,EAAIA,EAAI,EAAMzB,EAAEiM,EAAIC,GAAMzK,EAAIxB,EAAEgM,GAC5EI,EAAuB,KACvBC,EAA2B,GAkB3BC,EAAmB,EACnBC,EAAiB,KAYjBC,EAAmB,GACnBC,EAAkB,GAAOD,EAAmB,GAClD,SAASE,EAAYC,EAAKC,EAAKC,EAAKC,GAChC,GAAIH,IAAQC,GAAOC,IAAQC,EACvB,OAAO,KACX,MAAMC,EAAe,IAAIC,aAAaR,GACtC,IAAK,IAAI/L,EAAI,EAAGA,EAAI+L,IAAoB/L,EACpCsM,EAAatM,GAAKyL,EAAWzL,EAAIgM,EAAiBE,EAAKE,GAwB3D,OAAQrL,GAAY,IAANA,GAAiB,IAANA,EAAUA,EAAI0K,EAtBvC,SAAkBe,GACd,IAAIC,EAAgB,EAChBC,EAAgB,EACpB,MAAMC,EAAaZ,EAAmB,EACtC,KAAOW,IAAkBC,GAAcL,EAAaI,IAAkBF,IAAME,EACxED,GAAiBT,IAEnBU,EACF,MAEME,EAAYH,GAFJD,EAAKF,EAAaI,KAC3BJ,EAAaI,EAAgB,GAAKJ,EAAaI,IACXV,EACnCa,EAAenB,EAASkB,EAAWV,EAAKE,GAC9C,OAAIS,GAAgBf,EAhC5B,SAA8BU,EAAIM,EAASZ,EAAKE,GAC5C,IAAK,IAAIpM,EAAI,EAAGA,EAAI6L,IAAoB7L,EAAG,CACvC,MAAM+M,EAAerB,EAASoB,EAASZ,EAAKE,GAC5C,GAAqB,IAAjBW,EACA,OAAOD,EAGXA,IADiBrB,EAAWqB,EAASZ,EAAKE,GAAOI,GAC3BO,CAC1B,CACA,OAAOD,CACX,CAuBmBE,CAAqBR,EAAII,EAAWV,EAAKE,GAE1B,IAAjBS,EACED,EAvDnB,SAAyBJ,EAAIS,EAAIC,EAAIhB,EAAKE,GACtC,IAAIe,EACAC,EACApN,EAAI,EACR,GACIoN,EAAWH,GAAMC,EAAKD,GAAM,EAC5BE,EAAW1B,EAAW2B,EAAUlB,EAAKE,GAAOI,EACxCW,EAAW,EACXD,EAAKE,EAGLH,EAAKG,QAEJlQ,KAAK2D,IAAIsM,GAAYxB,KACxB3L,EAAI4L,GACV,OAAOwB,CACX,CA0CmBC,CAAgBb,EAAIC,EAAeA,EAAgBT,EAAiBE,EAAKE,EAExF,CACkDkB,CAASvM,GAAIoL,EAAKE,EACxE,C,wJCvEA,MAAMkB,EAAgBlG,GAAUtF,GAAK,EAAIsF,EAAO,EAAItF,GAC9CyL,EAAenG,GAAUtF,GAAKA,GAAK,GAAMsF,EAAO,EAAItF,GAAK,GAAK,EAAIsF,EAAO,GAAK,EAAItF,KAAO,EAEzF0L,EAAgBzF,GAAUjG,GAAKA,EAAIA,IAAMiG,EAAQ,GAAKjG,EAAIiG,GCG1D0F,EAAS3L,GAAKA,EACd4L,GAAsB,EDLI5L,GAAK7E,KAAKyC,IAAIoC,ECKlB,IAC5B,MAAM6L,EAAUL,EAAcI,GACxBE,EAAYL,EAAaG,GACzBG,EAAS/L,GAAK,EAAI7E,KAAK8D,IAAI9D,KAAK6Q,KAAKhM,IACrCiM,EAAUT,EAAcO,GACxBG,EAAYT,EAAaQ,GACzBE,EAAST,EAXoB,OAY7BU,EAAUZ,EAAcW,GACxBE,EAAYZ,EAAaU,GACzBG,EDZmB,CAACrG,IACtB,MAAMsG,EAAab,ECHY,ODI/B,OAAO1L,IAAMA,GAAK,GAAK,EACjB,GAAMuM,EAAWvM,GACjB,IAAO,EAAI7E,KAAKyC,IAAI,GAAI,IAAMoC,EAAI,IAAI,ECQ7BwM,GAIbC,EAAazM,IACf,GAAU,IAANA,GAAiB,IAANA,EACX,OAAOA,EACX,MAAM0M,EAAK1M,EAAIA,EACf,OAAOA,EArBoB,mBAsBrB,OAAS0M,EACT1M,EAtBsB,kBAuBlB,MAAQ0M,EAAK,IAAM1M,EAAI,IACvBA,EAvBiB,GAYpB,mBAYY0M,EAXZ,kBAWsB1M,EAVtB,kBAWO,KAAOA,EAAIA,EAAI,MAAQA,EAAI,KAAK,EAE5C2M,EAAWnB,EAAciB,GACzBG,EAAe5M,GAAMA,EAAI,GACzB,IAAO,EAAMyM,EAAU,EAAU,EAAJzM,IAC7B,GAAMyM,EAAc,EAAJzM,EAAU,GAAO,E,kCCnCvC,MAAM7C,EAAQ,CAAC0B,EAAKkC,EAAKH,IAAMzF,KAAK0D,IAAI1D,KAAK4F,IAAIH,EAAG/B,GAAMkC,E,kCCA1D,MAAM8L,EAAWC,GAAUA,EAAMC,eAAe,MAAQD,EAAMC,eAAe,KCEvEC,EAAaF,GAAUD,EAAQC,IAAUA,EAAMC,eAAe,K,gBCEpE,MAAME,EAAa,CAAC3P,EAAGC,IAAMpC,KAAK2D,IAAIxB,EAAIC,GAC1C,SAAS2P,EAAS5P,EAAGC,GACjB,IAAI,OAAMD,KAAM,OAAMC,GAClB,OAAO0P,EAAW3P,EAAGC,GAEpB,GAAIsP,EAAQvP,IAAMuP,EAAQtP,GAAI,CAC/B,MAAM4P,EAASF,EAAW3P,EAAE8P,EAAG7P,EAAE6P,GAC3BC,EAASJ,EAAW3P,EAAEgQ,EAAG/P,EAAE+P,GAC3BC,EAASP,EAAU1P,IAAM0P,EAAUzP,GAAK0P,EAAW3P,EAAEkQ,EAAGjQ,EAAEiQ,GAAK,EACrE,OAAOrS,KAAKC,KAAKD,KAAKyC,IAAIuP,EAAQ,GAAKhS,KAAKyC,IAAIyP,EAAQ,GAAKlS,KAAKyC,IAAI2P,EAAQ,GAClF,CACJ,C,kCCfA,MAKME,EAAS7M,GAAmB,iBAANA,C,kCCL5B,MAAMqB,EAAM,CAAClG,EAAMC,EAAI6I,KAAcA,EAAW9I,EAAO8I,EAAW7I,EAAKD,C,kCCAvE,MAAM2R,EAAmB,CAACpQ,EAAGC,IAAOqD,GAAMrD,EAAED,EAAEsD,IACxC6C,EAAO,IAAIkK,IAAiBA,EAAaC,OAAOF,E,kCCDtD,MAAM7I,EAAW,CAAC9I,EAAMC,EAAIK,KACxB,MAAMwR,EAAmB7R,EAAKD,EAC9B,OAA4B,IAArB8R,EAAyB,GAAKxR,EAAQN,GAAQ8R,CAAgB,C,iBCFzE,SAASC,EAAkBrR,EAAUsR,GACjC,OAAOA,EAAgBtR,GAAY,IAAOsR,GAAiB,CAC/D,C","sources":["webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/utils/find-spring.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/generators/spring.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/mix-color.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/mix-complex.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/interpolate.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/generators/keyframes.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/generators/decay.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/utils/elapsed.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/index.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/animations/inertia.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/easing/cubic-bezier.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/easing/utils.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/easing/index.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/clamp.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/is-point.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/is-point-3d.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/distance.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/inc.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/mix.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/pipe.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/progress.mjs","webpack://onemain-ui-exercise/./node_modules/popmotion/dist/es/utils/velocity-per-second.mjs"],"sourcesContent":["import { warning } from 'hey-listen';\nimport { clamp } from '../../utils/clamp.mjs';\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring, maxDamping, maxDuration, minDamping, minDuration };\n","import { __rest } from 'tslib';\nimport { findSpring, calcAngularFreq } from '../utils/find-spring.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n    const state = { done: false, value: from };\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let resolveVelocity = zero;\n    function createSpring() {\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        const initialDelta = to - from;\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        if (restDelta === undefined) {\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n        }\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (to -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq) *\n                            Math.sin(angularFreq * t) +\n                            initialDelta * Math.cos(angularFreq * t)));\n            };\n            resolveVelocity = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (dampingRatio *\n                    undampedAngularFreq *\n                    envelope *\n                    ((Math.sin(angularFreq * t) *\n                        (initialVelocity +\n                            dampingRatio *\n                                undampedAngularFreq *\n                                initialDelta)) /\n                        angularFreq +\n                        initialDelta * Math.cos(angularFreq * t)) -\n                    envelope *\n                        (Math.cos(angularFreq * t) *\n                            (initialVelocity +\n                                dampingRatio *\n                                    undampedAngularFreq *\n                                    initialDelta) -\n                            angularFreq *\n                                initialDelta *\n                                Math.sin(angularFreq * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            resolveSpring = (t) => to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta +\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\n                            t);\n        }\n        else {\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return (to -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                const currentVelocity = resolveVelocity(t) * 1000;\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: () => {\n            velocity = -velocity;\n            [from, to] = [to, from];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t) => 0;\n\nexport { spring };\n","function hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\nexport { hslaToRgba };\n","import { mix } from './mix.mjs';\nimport { hsla, rgba, hex } from 'style-value-types';\nimport { invariant } from 'hey-listen';\nimport { hslaToRgba } from './hsla-to-rgba.mjs';\n\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const toExpo = to * to;\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nconst notAnimatable = (color) => `'${color}' is not an animatable color. Use the equivalent color code instead.`;\nconst mixColor = (from, to) => {\n    let fromColorType = getColorType(from);\n    let toColorType = getColorType(to);\n    invariant(!!fromColorType, notAnimatable(from));\n    invariant(!!toColorType, notAnimatable(to));\n    let fromColor = fromColorType.parse(from);\n    let toColor = toColorType.parse(to);\n    if (fromColorType === hsla) {\n        fromColor = hslaToRgba(fromColor);\n        fromColorType = rgba;\n    }\n    if (toColorType === hsla) {\n        toColor = hslaToRgba(toColor);\n        toColorType = rgba;\n    }\n    const blended = Object.assign({}, fromColor);\n    return (v) => {\n        for (const key in blended) {\n            if (key !== \"alpha\") {\n                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n        return fromColorType.transform(blended);\n    };\n};\n\nexport { mixColor, mixLinearColor };\n","import { complex, color } from 'style-value-types';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { isNum } from './inc.mjs';\nimport { pipe } from './pipe.mjs';\nimport { warning } from 'hey-listen';\n\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = Object.assign(Object.assign({}, origin), target);\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction analyse(value) {\n    const parsed = complex.parse(value);\n    const numValues = parsed.length;\n    let numNumbers = 0;\n    let numRGB = 0;\n    let numHSL = 0;\n    for (let i = 0; i < numValues; i++) {\n        if (numNumbers || typeof parsed[i] === \"number\") {\n            numNumbers++;\n        }\n        else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            }\n            else {\n                numRGB++;\n            }\n        }\n    }\n    return { parsed, numNumbers, numRGB, numHSL };\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyse(origin);\n    const targetStats = analyse(target);\n    const canInterpolate = originStats.numHSL === targetStats.numHSL &&\n        originStats.numRGB === targetStats.numRGB &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p) => `${p > 0 ? target : origin}`;\n    }\n};\n\nexport { mixArray, mixComplex, mixObject };\n","import { progress } from './progress.mjs';\nimport { mix } from './mix.mjs';\nimport { mixColor } from './mix-color.mjs';\nimport { mixComplex, mixArray, mixObject } from './mix-complex.mjs';\nimport { color } from 'style-value-types';\nimport { clamp } from './clamp.mjs';\nimport { pipe } from './pipe.mjs';\nimport { invariant } from 'hey-listen';\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === 'number') {\n        return mixNumber;\n    }\n    else if (typeof v === 'string') {\n        if (color.test(v)) {\n            return mixColor;\n        }\n        else {\n            return mixComplex;\n        }\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === 'object') {\n        return mixObject;\n    }\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n    return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n    const inputLength = input.length;\n    const lastInputIndex = inputLength - 1;\n    return (v) => {\n        let mixerIndex = 0;\n        let foundMixerIndex = false;\n        if (v <= input[0]) {\n            foundMixerIndex = true;\n        }\n        else if (v >= input[lastInputIndex]) {\n            mixerIndex = lastInputIndex - 1;\n            foundMixerIndex = true;\n        }\n        if (!foundMixerIndex) {\n            let i = 1;\n            for (; i < inputLength; i++) {\n                if (input[i] > v || i === lastInputIndex) {\n                    break;\n                }\n            }\n            mixerIndex = i - 1;\n        }\n        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n        return mixers[mixerIndex](progressInRange);\n    };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\n    invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\n    if (input[0] > input[inputLength - 1]) {\n        input = [].concat(input);\n        output = [].concat(output);\n        input.reverse();\n        output.reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const interpolator = inputLength === 2\n        ? fastInterpolate(input, mixers)\n        : slowInterpolate(input, mixers);\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nexport { interpolate };\n","import { interpolate } from '../../utils/interpolate.mjs';\nimport { easeInOut } from '../../easing/index.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n    const numValues = values.length;\n    return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300, }) {\n    const state = { done: false, value: from };\n    const values = Array.isArray(to) ? to : [from, to];\n    const times = convertOffsetToTimes(offset && offset.length === values.length\n        ? offset\n        : defaultOffset(values), duration);\n    function createInterpolator() {\n        return interpolate(times, values, {\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),\n        });\n    }\n    let interpolator = createInterpolator();\n    return {\n        next: (t) => {\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: () => {\n            values.reverse();\n            interpolator = createInterpolator();\n        },\n    };\n}\n\nexport { convertOffsetToTimes, defaultEasing, defaultOffset, keyframes };\n","import { spring } from '../generators/spring.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { decay } from '../generators/decay.mjs';\n\nconst types = { keyframes, spring, decay };\nfunction detectAnimationFromOptions(config) {\n    if (Array.isArray(config.to)) {\n        return keyframes;\n    }\n    else if (types[config.type]) {\n        return types[config.type];\n    }\n    const keys = new Set(Object.keys(config));\n    if (keys.has(\"ease\") ||\n        (keys.has(\"duration\") && !keys.has(\"dampingRatio\"))) {\n        return keyframes;\n    }\n    else if (keys.has(\"dampingRatio\") ||\n        keys.has(\"stiffness\") ||\n        keys.has(\"mass\") ||\n        keys.has(\"damping\") ||\n        keys.has(\"restSpeed\") ||\n        keys.has(\"restDelta\")) {\n        return spring;\n    }\n    return keyframes;\n}\n\nexport { detectAnimationFromOptions };\n","function decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {\n    const state = { done: false, value: from };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    if (target !== ideal)\n        amplitude = target - from;\n    return {\n        next: (t) => {\n            const delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: () => { },\n    };\n}\n\nexport { decay };\n","function loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\nexport { hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\n","import { __rest } from 'tslib';\nimport { detectAnimationFromOptions } from './utils/detect-animation-from-options.mjs';\nimport sync, { cancelSync } from 'framesync';\nimport { interpolate } from '../utils/interpolate.mjs';\nimport { hasRepeatDelayElapsed, reverseElapsed, loopElapsed } from './utils/elapsed.mjs';\n\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => sync.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\n            clamp: false,\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0)\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        },\n    };\n}\n\nexport { animate };\n","import { animate } from './index.mjs';\nimport { velocityPerSecond } from '../utils/velocity-per-second.mjs';\nimport { getFrameData } from 'framesync';\n\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\n    }\n    function boundaryNearest(v) {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(Object.assign(Object.assign({}, options), { driver, onUpdate: (v) => {\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            }, onComplete,\n            onStop }));\n    }\n    function startSpring(options) {\n        startAnimation(Object.assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({ from, velocity, to: boundaryNearest(from) });\n    }\n    else {\n        let target = power * velocity + from;\n        if (typeof modifyTarget !== \"undefined\")\n            target = modifyTarget(target);\n        const boundary = boundaryNearest(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v) => {\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, getFrameData().delta);\n            if ((heading === 1 && v > boundary) ||\n                (heading === -1 && v < boundary)) {\n                startSpring({ from: v, to: boundary, velocity });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            from,\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\n        });\n    }\n    return {\n        stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(),\n    };\n}\n\nexport { inertia };\n","import { linear } from './index.mjs';\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\nconst c = (a1) => 3.0 * a1;\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (let i = 0; i < newtonIterations; ++i) {\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2)\n        return linear;\n    const sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","const reverseEasing = easing => p => 1 - easing(1 - p);\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\nconst createExpoIn = (power) => p => Math.pow(p, power);\nconst createBackIn = (power) => p => p * p * ((power + 1) * p - power);\nconst createAnticipate = (power) => {\n    const backEasing = createBackIn(power);\n    return p => (p *= 2) < 1\n        ? 0.5 * backEasing(p)\n        : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\n\nexport { createAnticipate, createBackIn, createExpoIn, mirrorEasing, reverseEasing };\n","import { createExpoIn, reverseEasing, mirrorEasing, createBackIn, createAnticipate } from './utils.mjs';\n\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nconst linear = p => p;\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\nconst circIn = p => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\nconst bounceOut = (p) => {\n    if (p === 1 || p === 0)\n        return p;\n    const p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD\n        ? 7.5625 * p2\n        : p < BOUNCE_SECOND_THRESHOLD\n            ? 9.075 * p2 - 9.9 * p + 3.4\n            : p < BOUNCE_THIRD_THRESHOLD\n                ? ca * p2 - cb * p + cc\n                : 10.8 * p * p - 20.52 * p + 10.72;\n};\nconst bounceIn = reverseEasing(bounceOut);\nconst bounceInOut = (p) => p < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))\n    : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n\nexport { anticipate, backIn, backInOut, backOut, bounceIn, bounceInOut, bounceOut, circIn, circInOut, circOut, easeIn, easeInOut, easeOut, linear };\n","const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nexport { clamp };\n","const isPoint = (point) => point.hasOwnProperty('x') && point.hasOwnProperty('y');\n\nexport { isPoint };\n","import { isPoint } from './is-point.mjs';\n\nconst isPoint3D = (point) => isPoint(point) && point.hasOwnProperty('z');\n\nexport { isPoint3D };\n","import { isPoint } from './is-point.mjs';\nimport { isPoint3D } from './is-point-3d.mjs';\nimport { isNum } from './inc.mjs';\n\nconst distance1D = (a, b) => Math.abs(a - b);\nfunction distance(a, b) {\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        const xDelta = distance1D(a.x, b.x);\n        const yDelta = distance1D(a.y, b.y);\n        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n    }\n}\n\nexport { distance };\n","const zeroPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nconst isNum = (v) => typeof v === 'number';\n\nexport { isNum, zeroPoint };\n","const mix = (from, to, progress) => -progress * from + progress * to + from;\n\nexport { mix };\n","const combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\nexport { pipe };\n","const progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n","function velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n"],"names":["safeMin","minDuration","maxDuration","minDamping","maxDamping","rootIterations","calcAngularFreq","undampedFreq","dampingRatio","Math","sqrt","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","spring","_a","from","to","restSpeed","restDelta","state","done","value","stiffness","damping","mass","velocity","duration","isResolvedFromDuration","springOptions","Object","assign","derived","bounce","envelope","derivative","clamp","exponentialDecay","delta","a","b","c","exp","d","e","pow","f","g","initialGuess","result","i","approximateRoot","isNaN","findSpring","getSpringOptions","resolveSpring","zero","resolveVelocity","createSpring","initialVelocity","initialDelta","undampedAngularFreq","min","abs","angularFreq","t","sin","cos","dampedAngularFreq","freqForT","sinh","cosh","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","flipTarget","needsInterpolation","_t","hueToRgb","p","q","hslaToRgba","hue","saturation","lightness","alpha","red","green","blue","round","mixLinearColor","v","fromExpo","toExpo","max","colorTypes","hex","rgba","hsla","getColorType","find","type","test","notAnimatable","color","mixColor","fromColorType","toColorType","fromColor","parse","toColor","blended","mix","transform","getMixer","origin","target","mixComplex","mixArray","output","numValues","length","blendValue","map","fromThis","mixObject","analyse","parsed","complex","numNumbers","numRGB","numHSL","template","createTransformer","originStats","targetStats","pipe","mixNumber","interpolate","input","isClamp","ease","mixer","inputLength","Array","isArray","concat","reverse","mixers","customMixer","mixerFactory","numMixers","easingFunction","push","createMixers","interpolator","progress","fastInterpolate","lastInputIndex","mixerIndex","foundMixerIndex","progressInRange","slowInterpolate","defaultEasing","values","easing","splice","keyframes","offset","times","o","convertOffsetToTimes","_value","defaultOffset","createInterpolator","types","power","timeConstant","modifyTarget","amplitude","ideal","loopElapsed","elapsed","delay","framesync","update","passTimestamp","start","stop","animate","_b","_c","autoplay","driver","repeat","repeatMax","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate","driverControls","latest","interpolateFromNumber","repeatCount","computedDuration","isComplete","isForwardPlayback","animator","config","Set","has","detectAnimationFromOptions","call","animation","hasRepeatDelayElapsed","reverseElapsed","inertia","bounceStiffness","bounceDamping","currentAnimation","isOutOfBounds","boundaryNearest","startAnimation","startSpring","boundary","heading","prev","checkBoundary","a1","a2","calcBezier","getSlope","subdivisionPrecision","subdivisionMaxIterations","newtonIterations","newtonMinSlope","kSplineTableSize","kSampleStepSize","cubicBezier","mX1","mY1","mX2","mY2","sampleValues","Float32Array","aX","intervalStart","currentSample","lastSample","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","binarySubdivide","getTForX","reverseEasing","mirrorEasing","createBackIn","linear","easeIn","easeOut","easeInOut","circIn","acos","circOut","circInOut","backIn","backOut","backInOut","anticipate","backEasing","createAnticipate","bounceOut","p2","bounceIn","bounceInOut","isPoint","point","hasOwnProperty","isPoint3D","distance1D","distance","xDelta","x","yDelta","y","zDelta","z","isNum","combineFunctions","transformers","reduce","toFromDifference","velocityPerSecond","frameDuration"],"sourceRoot":""}